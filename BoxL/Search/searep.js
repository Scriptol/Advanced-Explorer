/* Generated by Scriptol */

var fs = require('fs');
var scriptol = require('/solj/scriptol.js');

// Searep - Search & Replace - Freeware (c) 2004-2015  by Denis G. Sureau
// www.scriptol.com


// This program searches and replaces a string in a file,
// or the current directory and subdirectories.

// The search can be performed case-sensitive or not.
// One can search for identifiers in C, Scriptol or other sources,
// or any string in any pure ASCII text.

// By changing the "cdelimiters" string in strtools, you may specify what are identifiers.

eval(fs.readFileSync(__dirname + '/pattern.js')+'');

eval(fs.readFileSync(__dirname + '/strtools.js')+'');




var net=require('net');
var oslib=require('os');

var separator="/";
var isWin=false;


var client = net.connect({port: 1031}, function() {
  console.log("Replace.js open TCP connection to server...");
});

client.on('end',  function() {
     console.log('Replace.js: TCP connection closed by the server.');
});

os = oslib.platform();

if(os == "win32") {
  separator = "\\";
  isWin = true;
}


// Global declarations

var INLIST=false;
var TEXTCASE=false;
var QUIET=false;
var FILECASE=false;
var INCODE=false;
var RECURSE=true;
var VERBOSE=false;

var PADLEFT=scriptol.STR_PAD_LEFT;

var TOTAL=0;
var MATCHES=0;
var COUNTER=0;

var pattern="";
var searching="";
var replacing="";

function syntax(message)
{
   message=typeof message !== 'undefined' ? message : "";
   console.log("Search & Replace 1.7 - www.scriptol.com.");
   console.log("Syntax:   searep [option] search-string replacing-string file.");
   console.log("    or:   searep [option] search-string replacing-string pattern.");
   console.log("    or:   php -q searep.php etc...");
   console.log("Options:");
   console.log("  -l   search in list.");
   console.log("  -i   ignore case for strings (default case-sensitive).");
   console.log("  -c   search identifiers inside code (default string in text).");
   console.log("  -u   unix style, filename case sensitive (default ignore case).");
   console.log("  -l   current directory only (default recursively scan subdirectories).");
   console.log("  -v   verbose, display more infos.");
   console.log("  -q   quiet, don't display matches (default display).");
   console.log("  -iculv is the format for multiple options");
   console.log();
   if(!(message==="")) {
      console.log(message);
   }
   process.exit();
   return;
}
function buildPath(path,name)
{
   if(path.slice(-1)===separator) {
      return path+name;
   }
   return path+separator+name;
}
function display(content)
{
   console.log(content);
   
    var client = net.connect({port: 1031}, function() {
      client.end(JSON.stringify( {
        "type":"message", "app": "search", "content" : content
        }));
    });
    
   return;
}
// Open a file

function openfile(filename,mode)
{
   var f={};
   $error=(f=scriptol.fopen(filename,mode));
   if($error===false) {
      display("Enable to open "+filename);
      return false;
   }
   return f;
}
function clean(dstname)
{
   if(fs.existsSync(dstname)) {
      if(!fs.unlinkSync(dstname)) {
         display("Enable to clean "+dstname+" replacing cancelled.");
         return false;
      }
   }
   return true;
}

// Replace words in string
// as text.replace(), but case-sensitive or no, and count occurences

function replace(line)
{


   var sealen=searching.length;
   var replen=replacing.length;
   var linelen=line.length;

   if(TEXTCASE===false) {
      searching=searching.toLowerCase();
      line=line.toLowerCase();
   }

   var idx=0;
   var idr="";

   $_break0:while((idx+sealen)<linelen) {
      do {
         idx=line.indexOf(searching,idx);
         if(idx===-1) {
            break $_break0;
         }
         if(idx===0) {
            line=replacing+line.slice(idx+sealen);
         }         
         else {
            line=line.slice(0,idx-0)+replacing+line.slice(idx+sealen);
         }

         idx+=parseInt(replen);
         linelen=line.length;
         COUNTER+=1;
      } while(false);
   }
   return line;
}
// Replaces a file
// Makes it ".bak" and renames a temporary file to its name
// Change a temporary file into original file
// the original file become a .bak file

function replacefile(srcname,dstname)
{






   var node="";
   var ext="";
   $_I1=StrTools.splitExt(srcname);
   node=$_I1[0];
   ext=$_I1[1];
   if(fs.existsSync(node)) {
      if(ext!="") {
         node=srcname;
      }
   }

   var newname=node+".bak";
   fs.unlinkSync(newname);
   fs.renameSync(srcname,newname);
   fs.renameSync(dstname,srcname);
   return;
}

// Replace identifier in file
// Replace occurence of "searching" by "replacing" in file "filename"

function replaceid(srcname)
{

   if(VERBOSE) {
      display("Replacing identifier "+searching+" by "+replacing+" in "+heading(srcname));
   }

   // Making a temporary file
   var dstname=srcname+".tmp";
   if(!clean(dstname)) {
      return 0;
   }

   if(TEXTCASE===false) {
      searching=searching.toLowerCase();
   }
   var src=[];
   scriptol.arrayLoad(src,srcname);

   var linenum=0;
   var lowsearch=searching.toLowerCase();

   for(var line in src) {
      line=String(src[line]);
      var oldcounter=parseInt(COUNTER);
      var newline="";
      var srcwords=line.split(StrTools.cdelimiters);

      // Adding either same or replacing word

      for(var cmp in srcwords) {
         cmp=String(srcwords[cmp]);
         var word=cmp;
         if(searching===cmp) {
            word=replacing;
            COUNTER+=1;
         }         
         else {
            if((TEXTCASE===false)&&(lowsearch===cmp.toLowerCase())) {
               word=replacing;
               COUNTER+=1;
            }
         }
         newline+=word;
      }

      linenum+=1;
      src[cmp]=newline;

      if((!QUIET)&&(COUNTER>oldcounter)) {
         if(!VERBOSE) {
            display(heading(srcname)+": "+scriptol.pad(String(linenum),4,"0",PADLEFT)+": ");
         }
      }

   }



   var dst={};
   $error=(dst=scriptol.fopen(dstname,"w"));
   if($error===false) {      scriptol.die("enable to write on "+dstname);
   }   for(var line in src) {
      line=String(src[line]);      fs.appendFileSync(dst,line);
   }   scriptol.fclose(dst);



   replacefile(srcname,dstname);

   return COUNTER;
}

// Replace a string in an ascii file
// Replace occurences of "searching" by "replacing" in file "filename"

function replacestr(srcname)
{


   if(VERBOSE) {
      display("Replacing string \""+searching+"\" by \""+replacing+"\" in "+heading(srcname));
   }



   var dstname=srcname+".tmp";
   if(!clean(dstname)) {
      return 0;
   }

   var src=[];
   scriptol.arrayLoad(src,srcname);

   var linenum=1;

   for(var line in src) {
      line=String(src[line]);
      var oldcounter=parseInt(COUNTER);
      line=replace(line);
      if((!QUIET)&&(COUNTER>oldcounter)) {
         if(!VERBOSE) {
            process.stdout.write(String(heading(srcname))+": ");
         }
         process.stdout.write(scriptol.pad(String(linenum),4,"0",PADLEFT)+": "+line);
      }
      linenum+=1;
      src[line]=line;
   }

   var dst=openfile(dstname,"wb");
   if(dst===false) {
      return 0;
   }
   for(var line in src) {
      line=String(src[line]);      fs.appendFileSync(dst,line);
   }   scriptol.fclose(dst);
   // Now replacing the old file with the new updated one
   replacefile(srcname,dstname);

   return parseInt(COUNTER);
}

// Parsing the directory

function scanning(thedir)
{

   var dirarray=[];
   var filename="";
   var dirname="";

   if(VERBOSE) {
      display("<br><b>"+thedir+"</b>");
   }

   var dirlist=[];
   var filelist=[];
   if(scriptol.filetype(thedir)==="file") {
      filelist.push(thedir);
   }   
   else {
      filelist=fs.readdirSync(thedir);
   }

   for(filename in filelist) {
      filename=filelist[filename];
      if(filename==="") {
         break;
      }
      if(([".",".."].indexOf(filename)!=-1)) {
         continue;
      }

      filename=buildPath(thedir,filename);
      if(scriptol.filetype(filename)==="file") {
         TOTAL+=1;
         if(patmatch(pattern,filename,FILECASE)) {

            MATCHES+=1;
            if(INCODE===true) {
               replaceid(filename);
            }            
            else {
               replacestr(filename);
            }
         }
      }      
      else {
         dirlist.push(filename);
      }
   }

   if(RECURSE===false) {
      return;
   }

   for(dirname in dirlist) {
      dirname=dirlist[dirname];
      if(dirname==="") {
         break;
      }
      if(([".",".."].indexOf(dirname)!=-1)) {
         continue;
      }
      if(scriptol.filetype(dirname)==="dir") {
         scanning(dirname);
      }
   }

   return;
}
//---------------------------------------------------
//                   Main program
//---------------------------------------------------


function main(argnum,arglist)
{

   // The program requires 3 parameters plus one or two optionnals

   var s=arglist.length;
   if(s<3) {
      syntax(s+" arguments, 3 or more required.");
   }

   // Defaults

   TEXTCASE=true;
   QUIET=false;
   FILECASE=false;
   INCODE=false;
   RECURSE=false;

   // Processing options

   arglist.shift();
   var optstr=arglist[0];
   var optchr=optstr.charAt(0);

   $_break0:while((optchr==='-')||(optchr==='/')) {
      do {
         var opt=optstr.slice(1);
         arglist.shift();
         for(var $__3=0;$__3<opt.length;$__3++)          {
            var i=opt.charAt($__3);

            
            if(i==='l') {
               INLIST=true;
            }            
            else {
               if(i==='i') {
                  TEXTCASE=false;
               }            
            else {
               if(i==='c') {
                  INCODE=true;
               }            
            else {
               if(i==='u') {
                  FILECASE=true;
               }            
            else {
               if(i==='q') {
                  QUIET=true;
               }            
            else {
               if(i==='f') {
                  VERBOSE=true;
               }            
            else {
               if(i==='r') {
                  RECURSE=true;
               }            
            else {
               if(i==='v') {
                  VERBOSE=true;
               }            
            else {
               display(i+" bad option");
               syntax();
            }            }}}}}}}
         }
         optstr=arglist[0];
         optchr=optstr.charAt(0);
      } while(false);
   }

   if(arglist.length===3) {
      replacing=arglist[1];
      arglist.splice.apply(arglist,[1,1].concat([]));
   }   
   else {
      display("Wrong number of arguments...");
      syntax();
   }

   searching=arglist[0];
   pattern=arglist[1];

   if(VERBOSE) {
      display("Replacing "+searching+" by "+replacing);
   }

   if((replacing.charAt(0)==="-")||(searching.charAt(0)==="-")||(pattern.charAt(0)==="-")) {
      display("Put options at beginning...");
      syntax();
   }

   // Starting the search

   var searchpath=pattern;
   if(INLIST) {
      pattern="";
   }   
   else {
      if(wildcard(pattern)) {
         var p=pattern.indexOf("/");
         if((p>0)) {
            searchpath=pattern.slice(0,p-1-0+2);
            pattern=pattern.slice(p+1);
         }
      }
   }

   if(isWin) {
      searchpath=searchpath.replace("/","\\");
   }   
   else {
      searchpath=searchpath.replace("\\","/");
   }
   display("Searching for '"+searching+"' in "+searchpath);
   scanning(searchpath);

   var result="<hr>"+String(TOTAL)+" file"+(TOTAL>1?"s":"")+", "+String(MATCHES)+" file"+(MATCHES>1?"s":"")+" matching, "+String(COUNTER)+" occurence"+(parseInt(COUNTER)>1?"s":"")+" found.<hr>";
   display(result);

   return 0;
}
main(process.argv.length-1,process.argv.slice(1));


/* End */
