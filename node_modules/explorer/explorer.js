/*
    Explorer
    (c) 2012-2015 Denis Sureau
    Explorer.js is a node module for file management.
    Licence: LGPL 3.0
    Use it freely but do not change this copyright notice.
*/

var os = require('os');
var path = require('path');
var http = require('http');
var runner = require('child_process');
var fs = require('fs');
var zip = require("adm-zip");

var config = {};
exports.config = config;

var TEMPORARY = '/temp/';

var currpath = [];

exports.hello = function() { return("Hello World!"); }

exports.path = function (target) { return currpath[target]; }

exports.ostitle = '';

exports.loadIni = function (inipath)
{
    var platform = os.platform();
    console.log("Setup for OS "+ platform)
    var oslist = {
        'win32'  : '[Windows]',
        'linux'  : '[Linux]',
        'freebsd': '[Linux]',
        'darwin' : '[Mac]'
    }
    ostitle = oslist[platform];
  
	var data = fs.readFileSync(inipath, 'utf8');
	var lines = data.split(/\r\n|\r|\n/);
    var openos = false;

	for(var i = 0; i < lines.length; i++)
	{
	 	line = lines[i];
		if(line.length < 1) continue;
		if(line.charAt(0) == ';') continue;
		if(line.charAt(0) == '#') continue;
    if(line.charAt(0) == '[')
    {
       openos = false;
       if(ostitle==line)
          openos = true;   
       continue;     
    }
    if(openos) {
		  var kval = line.split(/\=/);
		  if(kval.length < 2) continue;
		  var k = kval[0].replace(/^\s\s*/, '').replace(/\s\s*$/, '');
		  var v = kval[1].replace(/^\s\s*/, '').replace(/\s\s*$/, '');
		  config[k] = v.replace(/^"(.*)"$/, '$1');
    }
	}
	//console.log(config);
  return platform;
}

function messageToInterface(ws, content)
{
   ws.send(JSON.stringify( {
    "app" : "AExplorer", 
    "type":"message",  
    "content" : content 
  }));
}


function buildDate(atime)
{
  var day = atime.getDate();
  if(day < 10) day = '0' + day;
  var month = atime.getMonth() + 1;
  if(month < 10) month = '0' + month;
  var hour = atime.getHours();
  if(hour < 10) hour = '0' + hour;
  var minute = atime.getMinutes();
  if(minute < 10) minute = '0' + minute;
  return( day + '/' + month + '/' + atime.getFullYear() + ' ' + hour + ':' + minute );
}

function noHTMLchars(s){
    s = s.replace(/&lt;/g, '<');
    s = s.replace(/&gt;/g, '>');
    s = s.replace(/&quot;/g, '"');
    s = s.replace(/&copy;/g, 'Â©');
    return s.replace(/&amp;/g, '&');
}

function getdir(websocket, fs, thepath, params)
{
  console.log("Getdir currentpath request: " + thepath + " target: " + params.target);

  thepath = thepath.replace(/\\/gi, "/");
  thepath = thepath.replace(/\/\//gi, "/");

  var sumsize = 0;
  var sumfile = 0;

  var result = fs.existsSync(thepath);
  if(!result) {
      messageToInterface(websocket, "Dir not found " + thepath);
      return;
  }

  fs.readdir(thepath, function(err, arrfiles)
	{
		var dirlist = [];
    if(thepath != "/")
    {
     		if((thepath.length > 3) || (thepath.length < 2) || (thepath.substr(1,2) != ':/'))
         		dirlist.push([ 'dir', '..']);
    }
    if(arrfiles==undefined) return;  
    console.log("thepath " + thepath+ ", " + arrfiles.length + " files");
		for(var i = 0; i < arrfiles.length; i++)
		{
			var name = arrfiles[i];
			var p = path.join(thepath , name);
      try
      {
			  var fdesc = fs.statSync(p);
        if (fdesc && fdesc.isDirectory())
        {
          dirlist.push( [ 'dir', name ] );
        }
        else
        {
          var thedate = buildDate(fdesc.mtime);
          dirlist.push( [ 'file', name, fdesc.size, thedate ] );
          sumsize += fdesc.size;
          sumfile ++;
        }
      }
      catch(e)  { console.log("Enable to read " + p);   }
	  }

		//console.log("Explorer getdir size=" + dirlist.length);
		fs.realpath(thepath, "", function (err, resolvedPath) {
			if (err) throw err;
			console.log("Explorer getdir resolvedPath: " + resolvedPath);
      currpath[params.target]= resolvedPath;
			websocket.send( JSON.stringify({
        "type": "dirdata", 
        'path': resolvedPath,
        'list' : dirlist,
        'target' : params.target,
        'iszip' : false,
        'drag' : params.drag
      } ));
			console.log("Explorer: Data sent to browser.");
      
      websocket.send(JSON.stringify({
        "type":"stats",
        "target": params.target,
        "files" : sumfile,
        "dirs"  : dirlist.length - sumfile,
        "size" : sumsize
         }));
		});
	 });  // readdir
}

function normalize(thepath, target) {
  thepath = path.join(currpath[target], thepath);
  thepath = thepath.replace(/\\/gi, "/");
  thepath = thepath.replace(/\/\//gi, "/");
  return thepath;
}

function fillBox(websocket, fs, params)
{
  var thepath = params.path;
  var target = params.target;
  var result = fs.existsSync(thepath);
  if(!result) {
      messageToInterface(websocket, "Dir not found " + thepath);
      return;
  }

  var dirlist = [];
  var content = "";
  var arrFiles = fs.readdirSync(thepath);
  if(arrFiles != undefined && arrFiles.length > 1)
	{
		for(var i = 0; i < arrFiles.length; i++)
		{
      var name = arrFiles[i]; 
      var p = path.join(thepath, name);
      try
      {
			  var fdesc = fs.statSync(p);
        if (fdesc != undefined && fdesc.isDirectory()) {
          dirlist.push(name);
        }  
      }
      catch(e)  { }
	  }
  }
  
	websocket.send( JSON.stringify({
       'type': 'box', 
       'path': thepath,
       'target': target,
       'list': dirlist
  } ));  
}


function readImage(websocket, fs, filepath)
{
  var ext = path.extname(filepath);
  console.log("Launching request for image: " + filepath);
  fs.exists(filepath, function(result) {
    	fs.readFile(filepath, function(err, file)
      {
         console.log("Request for image completed.");
         websocket.send(JSON.stringify({
          "type":"image", 
          "ext": ext, 
          "path": filepath
          ,"content" : new Buffer(file).toString('base64')
          }));
         return file;
      }
      );
    });
}

exports.readImage = readImage;

function setpath(filepath, target)
{
  currpath[target] = filepath;
  //console.log("setpath now " + currpath[target] + " " + target);
  return true;
}

function dirup(target)
{
  var p = currpath[target];
  p = p.replace(/\\/gi, "/");
  p = p.replace(/\/\//gi, "/");
  if(p.length > 1 && p.slice(-1) == "/") p = p.slice(0, -1);
  var x = p.lastIndexOf("/");
  currpath[target] = p.slice(0, x + 1);
  return true;
}

function subdir(sd, target)
{
  var p = currpath[target];

  if(sd=='.') return;

  if(sd == "/" || sd.charAt(1) == ':')  p = sd;
  else
  {
    if(p.slice(-1) != "/") p += "/";
    p += sd;
  }
  currpath[target] = p;
}

function chdir(filepath, target)
{
  console.log("chdir " + filepath + ' (current path: ' + currpath[target] +')');
  if(filepath.slice(-2) == "..") return dirup(target);
  if(filepath.charAt(0) == "/")
  {
    return setpath(filepath, target);
  }
  if(filepath.length > 2 && filepath.charAt(1) == ':')
  {
      currpath[target] = filepath;
      return true;
  }

	subdir(filepath, target);
  return true;
}

function godir(filepath, target)
{
    currpath[target] = filepath;
}

function mkdir(websocket, cpath, newdir)
{
  var p = path.join(cpath, newdir);
  fs.mkdir(p, '0777', function(err){
       if(err) 
        messageToInterface(websocket, "Enable to create " + p);
  });
}

function rename(websocket, fs, params)
{
  var target = params.target;
  var oldname = path.join(currpath[target], params.oldname);
  oldname=noHTMLchars(oldname);
  var newname = path.join(currpath[target], params.newname);
  try {
    fs.renameSync(oldname, newname);
  }
  catch(e) {
     messageToInterface(websocket, "Enable to rename " + oldname + " to " + newname + " " + e);
  }
}

var errorcount = 0;
function deletesub(basepath)
{
  try {
    var flist = fs.readdirSync(basepath);
  }
  catch(e) { return; }

  if(flist.length > 0)
  {
    for (var i = 0; i < flist.length; i++)
    {
      var fullpath = path.join(basepath, flist[i]);
      if (fs.statSync(fullpath).isDirectory())
        deletesub(fullpath);
      else
      {
        try
        {
          if(fs.unlinkSync(fullpath))
            errorcount++;
          else
            totalsize++;
        }
        catch(e) {
          errorcount++;
        }
      }
    }
  }
  fs.rmdirSync(basepath);
};

function deletelist(websocket, fs, params)
{
  var target = params.target;
  var flist = params.list;
  console.log("list len = " + flist.length);
  totalfile = 0;
  errorcount = 0;

  for(var i = 0; i < flist.length;i++)
  {
    if(flist[i]=='') continue;
    var p = path.join(currpath[target], flist[i]);
    var stats = fs.statSync(p);
    if(stats.isDirectory())
    {
      deletesub(p);
    }
    else
    {
      if(fs.unlinkSync(p))
         errorcount++;
      else
         totalsize++;
    }
  }

  var message =  totalsize + " deleted";
  if(errorcount) message += ", " + errorcount + " not deleted";
  message += '.';

  console.log("Deleted");
  websocket.send(JSON.stringify({
    "type":'notification',  
    "action": 'update', 
    'target' : target 
  }));
  websocket.send(JSON.stringify({"type":'status', 'content' : message }));
}

function copySync(sourcepath, targetpath)
{
  var buffer = new Buffer(65536);
  var readHandle = fs.openSync(sourcepath, 'r');
  var writeHandle = fs.openSync(targetpath, 'w');
  var size;
  var seekoffset = 0;

  try {
    do
    {
      size = fs.readSync(readHandle, buffer, 0, 65536, seekoffset);
      if(size > 0)
        fs.writeSync(writeHandle, buffer, 0, size);
      seekoffset += size;
    }
    while (size > 0);
  } catch(e) {
     console.log("Error, enable to copy " + sourcepath + ", " + e.message);
  }

  fs.closeSync(readHandle);
  fs.closeSync(writeHandle);
  return;
}

function copyIf(ws, sourcepath, targetpath, promptdup)
{
  //console.log("CopySync " + sourcepath + " " + targetpath);
  if(promptdup)
  {
    if(fs.existsSync(targetpath))
    {
      console.log(targetpath + " already exists...");
      ws.send(JSON.stringify( {
        "type":"confirm",
        "question" : targetpath + " already exists. Overwrite?",
        "data": {        
        "command": "copyover",
        "path" : sourcepath,
        "target" : targetpath, 
        }
      }));
      return;
    }
  }
  copySync(sourcepath, targetpath);
  return;
};


function copysub(websocket, flist, source, target)
{
  for(var i = 0; i < flist.length; i++)
  {
    var nextfile = flist[i];
    if(nextfile=='') continue;
    var sourcepath = path.join(source, nextfile);
    var targetpath = path.join(target, nextfile);
    
    sourcepath = noHTMLchars(sourcepath);
    
    var info = "Copying "+ sourcepath + " to " + target;
    console.log(info);
    websocket.send(JSON.stringify({
      "type":"status", 
      "content": info 
    } ));
    var stats = fs.statSync(sourcepath);
    if(stats.isDirectory())
    {
      if(!fs.existsSync(targetpath))
        fs.mkdirSync(targetpath);
      var sublist = fs.readdirSync(sourcepath);
      copysub(websocket, sublist, sourcepath, targetpath);
    }
    else if(stats.isFile())
    {
      copyIf(websocket, sourcepath, targetpath, true);
    }
  }

}

function filecopy(websocket, fs, params)
{
  var selection = params.list;
  if(selection.length == 0)
  {
    console.log("No file to copy.")
    return;
  }
  var source = currpath[params.source];
  var target = currpath[params.target];
  copysub(websocket, selection, source, target);

  var s = ""; if(selection.length > 1) s = "s";

  websocket.send(JSON.stringify({
    "type":"notification",  
    "action": "update", 
    "target" : params.target } ));
  websocket.send(JSON.stringify({
    "type":"status", 
    "content": selection.length + ' file' + s + ' copied.' 
    } ));
  console.log(selection.length + " files copied.");
}

function copyrename(websocket, fs, params)
{
  var messager = params.messager;
  var source = currpath[params.source];
  var target = currpath[params.target];
  var oldname = params.oldname;
  var newname = params.newname;
  var sourcepath = path.join(source, oldname);
  var targetpath = path.join(target, newname);
  console.log("Copying " + sourcepath + " as " + targetpath);

  if(params.isDirectory)
  {
    fs.mkdir(targetpath);
    var arrfiles = fs.readdirSync(sourcepath);
	  copysub(websocket, arrfiles, sourcepath, targetpath);
  }
  else
    copyIf(websocket, sourcepath, targetpath, true);

  websocket.send(JSON.stringify({
    "type":'status',  
    'content': oldname + " copied as " + newname } ));
  websocket.send(JSON.stringify({
    "type":'notification',  
    'action': 'update', 
    'target' : params.target } ));
}


function synchrosub(websocket, flist, source, target, recurse, copyAll, total)
{
  if(flist.length == 0)
  {
    flist = fs.readdirSync(source);
    if(flist.length==0) return;
  }

  for(var i = 0; i < flist.length; i++)
  {
    var nextfile = flist[i];
    if(nextfile=='') continue;
    var sourcepath = path.join(source, nextfile);
    var targetpath = path.join(target, nextfile);
    sourcepath = noHTMLchars(sourcepath);
    
    var stats = fs.statSync(sourcepath);
    if(stats.isDirectory())
    {
      if(!recurse) continue;
      if(!fs.existsSync(targetpath))  {
        if(!copyAll) continue;      
        fs.mkdirSync(targetpath);
      }  
      var sublist = fs.readdirSync(sourcepath);
      synchrosub(websocket, sublist, sourcepath, targetpath, true, copyAll, total);
    }
    else 
    if(stats.isFile())
    {
      var newer = copyAll;
      if(fs.existsSync(targetpath)) {
          var tstat = fs.statSync(targetpath); 
          if(stats.mtime.getTime() > tstat.mtime.getTime()) newer = true;
      }
      if(newer) {
        var info = "Copying "+ sourcepath + " to " + target;
        console.log(info);
        websocket.send(JSON.stringify({ "type":"status", "content": info } ));
        copySync(sourcepath, targetpath);
        total++;
      }  
    }
  }
  return total;
}

function synchronize(websocket, fs, params)
{
  var source = currpath[params.source];
  var target = currpath[params.target];

  var selection = params.list;
  console.log("Synchronizing from " + source + " to "+ target);
  var total = synchrosub(websocket, selection, source, target, params.recursive, params.copyall, 0);

  var s = ""; if(total > 1) s = "s";

  websocket.send(JSON.stringify({ "type":"notification","action": "update", "target" : params.target } ));
  websocket.send(JSON.stringify({ "type":"status",  "content": total + ' file' + s + ' copied or updated.'  } ));
  console.log(total + " files copied or updated.");
}

/* Read the content of a file, send it to the editor */

function getContent(websocket, fs, params)
{
	var target = params.target;
	var fullpath = params.path;
	if(target != null) {
	  fullpath = path.join(currpath[target], fullpath);
	}
    //console.log("GETCONTENT " + fullpath)
	var here = fs.existsSync(fullpath);
	if(!here) {
	    console.log("File '" + fullpath + "' not found...");
	    return;
	}    

    var stats = fs.statSync(fullpath);
    if(stats.isDirectory())
    {
	    messageToInterface(websocket, "Can't edit " + fullpath + ", it is a directory.");
	    return;
    }
    var data = new String(fs.readFileSync(fullpath));

    if(data.length >= 127)
    {
        var lenstr = new String(data.length);
        lenstr = '0000000' + lenstr;
        lenstr = lenstr.slice(0, 8);
        data = String.fromCharCode(127) + lenstr + data;
    }

    var ext = path.extname(fullpath);

    var type="editor";
    if(params.inEditor) type = "openDoc";

    websocket.send(JSON.stringify({
        "type":type, 
        'ext': ext.substr(1),
        'content': data, 
        'filename': fullpath,
        'newPrj': params.newPrj,
        'project' : params.project 
    }));
    console.log("Data sent...");

    websocket.send(JSON.stringify({"type":'status', 'content' : fullpath }));
}

function openProject(websocket, fs, params)
{
	var fullpath = params.name;
  var target = params.target;
	if(target != null) {
        fullpath = path.join(currpath[target], fullpath);
	} 
  
	var here = fs.existsSync(fullpath);
	if(!here) {
	    console.log("Project file '" + fullpath + "' not found...");
	    return;
	}    
  var data = new String(fs.readFileSync(fullpath));
  var obj = JSON.parse(data);

  if(obj == null || ! ("type" in obj) || obj.type != "AEPrj") {
        messageToInterface(websocket, filename + " is not a valid Advanced Explorer project.")
        return;
  }

  params.project = {
      "list" : obj.list,
      "projectName" : fullpath
    }
  params.inEditor = false; 
  params.target = null;
  if(obj.active == "") {
    obj.active = obj.list[0];
  }
  params.path = obj.active;
  getContent(websocket, fs, params);
}


function updateIni(websocket, fs, params)
{
  var root = path.resolve('./');
  var fullpath = path.join(root, params.path);  
	var here = fs.existsSync(fullpath);
	if(!here) {
	    console.log("Ini file '" + fullpath + "' not found...");
	    return;
	}    
  var data = new String(fs.readFileSync(fullpath));
  websocket.send(JSON.stringify({
        "type":"updateIni", 
        'content': data 
  }));
  console.log("Ini loaded.");  
}


function savefile(websocket, fs, params)
{
  var fullpath = params.filename;

  if(!params.overwrite)
  {
    if(fs.existsSync(fullpath))
    {
      var stats = fs.statSync(fullpath);
      if(stats.isDirectory())
      {
        websocket.send(JSON.stringify({
                    "type":'editor',  
                    'message': "It is the name of a directory." 
        }));
        return;
      }
      websocket.send(JSON.stringify({
                "type":'editor',  
                'action':'prompt', 
                'message' : "Already exists. Erase it?" 
      }));
    }
  }
  fs.writeFile(fullpath, params.content, function(err) {
    var message = (err ? 'Not saved' : 'Saved') + ' into ' + fullpath;
    console.log(message);
    if(err)
      websocket.send(JSON.stringify({"type":'editor',  'message': message }));
    else  
      websocket.send(JSON.stringify({"type":'status', 'content' : message }));
  });
}

function store(websocket, fs, params)
{
  var fullpath = path.join(process.cwd() , params.filename);

  var err = fs.writeFileSync(fullpath, params.content);
  var message = (err ? 'Not saved' : 'Saved') + ' into ' + fullpath; 
  console.log(message);
  websocket.send(JSON.stringify({"type":'status', 'content' : message }));
}



function savePrj(websocket, fs, params)
{
  var fullpath = params.name;

  var prj = {
    "type": "AEPrj",
    "active": params.active,
    "list": params.list
  }

  var err = fs.writeFileSync(fullpath, JSON.stringify(prj, null, "  ")); 
  var message = (err ? 'Not saved' : 'Saved') + ' into ' + fullpath;
  console.log(message);
  if(err)
      websocket.send(JSON.stringify({"type":'editor',  'message': message }));
  else
      websocket.send(JSON.stringify({"type":'status', 'content' : message }));
}

function saveSysFile(websocket, fs, params)
{
	var fullpath = params.filename;
    var root = path.resolve('./');
    fullpath = path.join(root, fullpath);
    console.log("Save system file " + fullpath);
    var result = fs.writeFileSync(fullpath, params.content);
    var message = (result ? 'Not saved' : 'Saved') + ' into ' + fullpath;
    console.log(message);
}



function isempty(websocket, fs, params)
{
  var target = params.target;
  var fullpath = path.join(currpath[target], params.filename);

  fs.exists(fullpath, function (r) {
    if(!r) {
      messageToInterface(websocket, "Dir not found " + fullpath);
      return;
    }
    fs.readdir(thepath, function(err, arrfiles)
	  {
       messageToInterface(websocket, arrfile.length);
    });
  });
}

var totalsize = 0;
var totalfile = 0;

function infosub(basepath)
{
  //console.log("path " + basepath);

  var selection = fs.readdirSync(basepath);
  for(var i = 0; i < selection.length; i++)
  {
    var nextentry = path.join(basepath, selection[i]);
    var stats = fs.statSync(nextentry);
    //console.log("next file to test " + nextentry);
    if(stats.isDirectory())
    {
       //console.log("open dir " + nextentry);
       infosub(nextentry);
    }
    else
    if(stats.isFile())
    {
       totalsize += stats.size;
       totalfile ++;
    }
  }

}

function dirinfo(websocket, fs, params)
{
  var target = params.target;
  var lst = params.filelist;
  totalsize = 0;
  totalfile = 0;

  for(var i = 0; i < lst.length; i++)
  {
    var fullpath = path.join(currpath[target], lst[i]);
    console.log("Next entry " + fullpath);
    var stats = fs.statSync(fullpath);
    if(stats.isDirectory())
    {
      infosub(fullpath);
    }
    else
    {
      totalsize += stats.size;
      totalfile++;
    }
  }
  var sizestr = "";
  if(totalsize > 1000000)
  {
    var ms = parseInt(totalsize / 1000000, 10);
    sizestr = ms + " megas ("+ totalsize + " bytes)";
  }
  else
    sizestr = totalsize + " bytes";

  websocket.send(
    JSON.stringify( {
      "type":"dirinfo",
      "content" : sizestr +  ", in " + totalfile + " files" 
    })
  );
}


function makeThumbnail(websocket, fs, filepath, data)
{
  console.log("Calling resizer... ");
  fs.exists(filepath, function(result) {
    var prefix = data.prefix;
    var imagefile = data.imagefile.replace(/\/\//gi, "/");
    var ext = data.ext;
    var format = data.format.toLowerCase();
    var scriptparam = " -w" + data.width + " -h"+ data.height;
    if(ext.charAt(0).toLowerCase() != format)
      scriptparam +=  " -" + format;

    scriptparam += ' ' + imagefile;
    console.log('Command: ' + "php " + filepath + " " + scriptparam);
    var r = runner.exec("php " + filepath + " " + scriptparam,  function(err, stdout, stderr) {
        console.log(stdout);
    }); // exec

    console.log(filepath + " launched by the server...");
    r.on('exit', function (code) {
      console.log('Local script terminated. Sending ' + data.thumbfile + " to the interface.");

    	fs.readFile(data.thumbfile, function(err, file) {
        console.log("Request completed.");
        websocket.send(JSON.stringify({
          "type":'thumbnail', 
          'params' : data,
          'content' : new Buffer(file).toString('base64')
        }));  
      }); // readfile
     }); // on exit
  });   //exists
}


function loadPage(filename, cb)
{
	var browserName = config.browser;
  var browser = config[browserName];
  
	console.log("Loading..." + filename);
	if(!fs.existsSync(browser))
  {
		console.log("File not found " + browser)
    return false;
  }
	var command = browser + " \"" + filename + "\"";
	console.log("Running " + command);
	runner.exec(command, function(err, stdout, stderr) {
      //console.log("Terminated. "+ stderr);
      //if(delflag)
      if(cb != null)  cb();
      return true;
  });
}


function zipify(fname)
{
  if(fname.length > 2)
    if(fname.charAt(1) == ':')
      fname = fname.slice(2);

  fname = fname.replace(/\\/gi, '/');
  if(fname.charAt(0)== '/') return(fname.slice(1));
  return(fname);
}


/*
  Create an archive with the archiver in the config
*/

function archive(websocket, fs, params)
{
  var source = params.source;
  var target = params.target;
  var orig = currpath[source];
  var dest = currpath[target];
  var zipname = params.zipname;
  var flist = params.list;

  var command = params.archiver;
  command += " " + path.join(dest, zipname);

  for(var i = 0; i < flist.length; i++)
  {
    var entry = flist[i];
    var filepath = path.join(orig, entry);
    var fdesc = fs.statSync(filepath);
    if (fdesc && fdesc.isDirectory())
      filepath += "/*";

    command += " " + filepath;
  }

  console.log("Archive command: " + command);

  runner.exec(command, function(err, stdout, stderr) {
      console.log("Terminated. "+ stderr);
      if(err) {
        messageToInterface(websocket, "Enable to create " + zipname);
      }  
      else {
        websocket.send(JSON.stringify({
          "type":'notification',  
          'action': 'update', 
          'target' : params.target 
        }));
      }    
  });

}


function archiveBak(websocket, fs, params)
{
  var target = params.target;
  var orig = currpath[params.source];
  var dest = currpath[target];
  var zipname = params.zipname;
  var flist = params.list;

  console.log("Creating " + zipname + " List size : " + flist.length);

  var zipfile = new zip();

  for(var i = 0; i < flist.length; i++)
  {
    var entry = flist[i];
    if(entry=='') continue;
    origpath =  path.join(orig, entry);
    var zipath = zipify(origpath);
    //console.log("Adding " + zipath);
    var buffer = fs.readFileSync(origpath);
    zipfile.addFile(zipath, buffer, null, 0666);
  }

  zipfile.writeZip(path.join(dest, zipname));

  websocket.send(JSON.stringify({
    "type":'notification', 
    'action': 'update', 
    'target' : target 
  } ));
}

function viewfile(websocket, fs, params)
{
  loadPage(params.path);
}

function viewzip(websocket, fs, params)
{
  var target = params.target;
  //var zipname = path.join(currpath[target], params.filename);
  var zipname = params.path;
  console.log("Zip file: " + zipname);
  try {
    var zipfile = new zip(zipname);
    var zipEntries = zipfile.getEntries();
  } catch(e) {
    messageToInterface(websocket, 'Enable to open '+ zipname + " archive.");
    return;
  }
	var dirlist = [];
  var thedate = null;

  for(var i = 0; i < zipEntries.length; i++)
  {
    var zipEntry = zipEntries[i];
    var name = zipEntry.entryName;
    //console.log("Next entry "+ name);
    var size = zipEntry.header.size;
    if (zipEntry.isDirectory)
    {
      dirlist.push( [ 'dir', name ] );
    }
    else
    {
      thedate = buildDate(zipEntry.header.time);
      dirlist.push( [ 'file', name, size + '&nbsp;&nbsp;' + thedate ] );
    }
  }

	websocket.send(JSON.stringify({
    "type":'dirdata', 
    'path': zipname,
    'list' : dirlist,
    'target' : params.target,
    'iszip': true
  } ));

  // extracts everything
  //zipfile.extractAllTo(targetpat, true);
}

function copyZipOver(websocket, data)
{
  var zipfile = data.zip;
  var filename = data.filename;
  var target = data.targetPath;
  var keepath = data.keepath;
  try
  {
    zipfile.extractEntryTo(filename, targetPath, keepath, true);
  }
  catch(e) { };  
}

function extractSub(websocket, zipfile, filename, target, keepath, overwrite)
{
  var zipEntry = zipfile.getEntry(filename);
  if(zipEntry == false) {
    console.log("Error in zip...");
    return false;
  }
  var targetNode = filename;
  var targetPath = currpath[target];
  if(!keepath)  {
      var pos = filename.lastIndexOf("/");
      targetNode = filename.substr(pos + 1);
  }
  //console.log("fname:"+ filename)
  //console.log("tpath:" + targetPath)
  var targetFile = path.join(targetPath, targetNode);
  //console.log("targetFile:" + targetNode)
  console.log("Extracting file: " + filename + " to " + targetPath);
  if(!overwrite)
  {
      if(fs.existsSync(targetFile) && !overwrite)
      {
        websocket.send(JSON.stringify( {
        "type":"confirm",
        "question" : targetFile + " already exists. Overwrite?",
        "data": {        
        "command": "copyzip",
        "filename" : filename,
        "targetFile" : targetPath,
        "zip": zipfile,
        "keepath": keepath
        }
        }));          
      }
  }
  try
  {
    zipfile.extractEntryTo(filename, targetPath, keepath, true);
  }
  catch(e) { };
  return true;
}

// Extract a file or a set from an archive

function extract(websocket, fs, params)
{
  var target = params.target;
  var zipname = fs.realpathSync(params.archive);
  var zipfile = new zip(zipname);
  var filelist = params.filelist;
  console.log(filelist.length+" to extract. Keep path=" + params.keepath + " Overwrite="+ params.overwrite);
  for(var i = 0; i < filelist.length; i++)
  {
    var filename = filelist[i];
    //console.log("Next:"+ filename);
    extractSub(websocket, zipfile, filename, target, params.keepath, params.overwrite);
  }
  websocket.send(JSON.stringify({
    "type":'notification', 
    'action':'update',
    'target':'rcontent' 
  }));
  return;
}

function textinzip(websocket, fs, params)
{
  var zipname = fs.realpathSync(params.archive);
  var zipfile = new zip(zipname);
  var entryname = params.entryname;
  console.log("Reading in zip " + entryname);
  var zipEntry = zipfile.getEntry(entryname);
  if(zipEntry != null && zipEntry != false)
  {
    var tempdir = process.cwd() + TEMPORARY;
    if(!fs.existsSync(tempdir)) fs.mkdir(tempdir);
    try {
      zipfile.extractEntryTo(zipEntry.entryName, tempdir, false, true);
    } 
    catch(e)
    {
      messageToInterface(websocket, 'Enable to extract. See the issues page.');
      return;
    }
    var tempfile = tempdir + path.basename(entryname);
    console.log("Loading "+ tempfile);
    loadPage('file:///' + tempfile, function() {
      fs.unlinkSync(tempfile);
    });
  }
  return;
}

function unzip(websocket, fs, params)
{
  var target = params.target;
  var overwrite = params.overwrite; 
  var zipname = path.join(currpath[params.source], params.archive);
  zipname = fs.realpathSync(zipname);
  console.log("Unzip " + zipname + " to " + currpath[params.target] + " overwrite="+ overwrite);
  var zipfile = new zip(zipname);

  try {
    zipfile.extractAllTo(currpath[target], overwrite);
  } catch(e) {
    messageToInterface(websocket, 'Enable to extract. See the issues page.');
    return;
  }
  websocket.send(JSON.stringify({
    "type":'notification', 
    'action':'update','target':target 
  }));
  return;
}

/*
  Executable
*/
/*
function execute(websocket, params)
{
  var target = params.target;
  var filename = params.filename;
  var dest = currpath[target];
  if(filename==null)
    filename = params.path;
  else
    filename =  path.join(dest, filename);
  var command = 'start ' + filename;
  console.log("Execute: " + command);
  runner.exec(command, function(err, stdout, stderr) {
      console.log("Terminated. "+ stderr);
      if(err) messageToInterface(websocket, "Enable to execute " + filename);
  });
}
*/

/* run a script */

function run(websocket, params)
{
  var command = "";
  if(params.program != null) command = params.program + " ";
  var script = path.join(process.cwd(), params.script);
  var args = script + " " + params.options;
  command += " " + args; 
  console.log(command );
  
  //var ret = runner.execSync(command);
  //console.log(ret);

  var child = runner.exec(command);
  child.stdout.on('data', function(data) {
    console.log('Stdout: ' + data);
  });
  child.stderr.on('data', function(data) {
    console.log('Stderr: ' + data);
  });
  child.on('close', function(code) {
    console.log('Closed with: ' + code);
  });
  
}

function progressOn(ws) {
  ws.send(JSON.stringify( { "type":"mouse",  'pointer' : 'progress' } ));
}

function progressOff(ws) {
  ws.send(JSON.stringify( { "type":"mouse",  'pointer' : 'auto' } ));
}


exports.shell = function(websocket, fs, params)
{
	var command = params.command;
	console.log("Explorer command: " + command);
  var target = null;
  if('target' in params) target = params.target;

  progressOn(websocket);

	switch(command)	{
	case 'getdir':
        subdir(params.path, target);
        getdir(websocket, fs, currpath[target], params);
        break;
  case 'saveas':
        subdir(params.path, target);
        getdir(websocket, fs, params.path, params);  
        break;
	case 'chdir':  // go to subdir or reload
        chdir(params.path, target);
        getdir(websocket, fs, currpath[target], params);
        break;
	case 'godir':
        godir(params.path, target);
        getdir(websocket, fs, currpath[target], params);
        break;
	case 'dirup':
        dirup(target);
        getdir(websocket, fs, currpath[target], params);
        break;
	case 'mkdir':
        mkdir(websocket, currpath[target], params.path);
        getdir(websocket, fs, currpath[target], params);
        break;
	case 'rename':
        rename(websocket, fs, params);
        break;
	case 'unlink':
        deletelist(websocket, fs, params);
        break;
	case 'filecopy':
  		filecopy(websocket, fs, params);
  		break;
    case 'sync':
        synchronize(websocket, fs, params);
        break;    
    case 'copyover':
        copyIf(websocket, params.path, target, false);
        break;
    case 'copyzip':
        copyZipOver(websocket, command);
        break;      
	case 'copyrename':
        copyrename(websocket, fs, params);
  		break;
	case 'getContent':
        params.project=null;
        params.newPrj = false;
        getContent(websocket, fs, params);
        break;
    case 'openPrj':
        openProject(websocket, fs, params);
        break;
	case 'updateIni':
        updateIni(websocket, fs, params);
		break;      
	case 'savePrj':
		savePrj(websocket, fs, params);
		break;      
	case 'isempty':
		filecopy(websocket, fs, params);
		break;
	case 'archive':
		archive(websocket, fs, params);
		break;
	case 'dirinfo':
		dirinfo(websocket, fs, params);
		break;
	case 'loadimage':
		console.log("Explorer shell request filepath : " + params.path);
		readImage(websocket, fs, params.path);
		break;
	case 'thumbnail':
		console.log("Building thumbnail of " + params.imagefile)
		makeThumbnail(websocket, fs, params.path, params);
		break;
	case 'viewtext':
		viewfile(websocket, fs, params);
		break;
	case 'save':
    	savefile(websocket, fs, params);
    	break;
	case 'store':
    	store(websocket, fs, params);
    	break;      
	case 'savesys':
    	saveSysFile(websocket, fs, params);
    	break;
	case 'viewzip':
    	viewzip(websocket, fs, params);
    	break;
	case 'textinzip':
    	textinzip(websocket, fs, params);
    	break;
	case 'unzip': // whole archive
    	unzip(websocket, fs, params);
    	break;
  case 'extract':
      extract(websocket, fs, params);
      break;  
	case 'box':
        fillBox(websocket, fs, params);
        break;
/*        
	case 'execute':
		execute(websocket, params);
		break;
*/            
  case 'run':
        run(websocket, params);
        break;      
	case 'quit':
      progressOff(websocket);
      console.log("Bye...");
      websocket.close();
    	process.exit(0);
    	break;
	default:
      progressOff(websocket);
		  messageToInterface(websocket, 'Unknow command '+command+' to Explorer');
      console.log(command + " unknow.");
	}
  progressOff(websocket);
}